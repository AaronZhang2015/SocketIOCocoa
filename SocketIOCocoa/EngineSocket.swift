import Foundation

// The delegate for EngineSocket
public protocol EngineSocketDelegate: class{
    // Called when the socket state is Open
    func socketOnOpen(socket: EngineSocket)
    
    // Called when the socket state is Closed
    func socketOnClose(socket: EngineSocket)
    
    // Called when there is a message decoded
    func socketOnData(socket: EngineSocket, data: [Byte], isBinary: Bool)
    
    // Called when there is an error occured
    func socketOnError(socket: EngineSocket, error: String, description: String)
}

enum EngineSocketReadyState : Int, Printable{
    case Init, Open, Opening, Closing, Closed, Upgrading
    
    var description: String {
        switch self{
        case .Init: return "Init"
        case .Open: return "Open"
        case .Opening: return "Opening"
        case .Closing: return "Closing"
        case .Closed: return "Closed"
        case .Upgrading: return "Upgrading"
        }
    }
}

// A counter which counts how many EngineSocket created
var socketCount: Int = 0

public class EngineSocket: EngineTransportDelegate{
    // Whether the protocol is secure
    var secure: Bool = false
    
    // Host
    var host: String
    
    // Port
    var port: String
    
    // Path
    var path: String
    
    // Sid generated by server, unique identifier for one socket client
    var id: String?
    
    // The running queue, create it when create a new instance
    var queue: dispatch_queue_t = {
        ++socketCount
        return dispatch_queue_create("com.menic.EngineIO-queue\(socketCount)", DISPATCH_QUEUE_SERIAL)
        }()
    
    // Available transports
    var transports: [String]
    
    // Whether the socket should upgrade
    var upgrade: Bool
    
    // Hold for available upgrades
    var upgrades: [String] = ["websocket"]
    
    // Flag indicating whether we are in the upgrading phase
    var upgrading: Bool = false
    
    // The state of socket
    var readyState: EngineSocketReadyState = .Init
    
    // Transport instance
    var transport: Transport?
    
    // Ping interval
    var pingInterval: Int = 30000
    
    // Ping timeout
    var pingTimeout: Int = 30000
    
    // The write queue
    var writeQueue: [EnginePacket] = []
    
    // The write calllback queue
    var writeCallbackQueue: [(()->Void)?] = []
    
    // The delegate
    public weak var delegate: EngineSocketDelegate?
    
    public init(host: String, port: String, path: String = "/socket.io/", secure: Bool = false,
        transports: [String] = ["polling", "websocket"], upgrade: Bool = true, config: [String:AnyObject] = [:]) {
            self.host = host
            self.port = port
            self.path = path
            self.transports = transports
            self.upgrade = upgrade
    }
    
    func createTransport(transportName: String) -> Transport? {
        var transport : Transport? = nil
        if $.contains(self.transports, value: transportName){
            if transportName == "polling" {
                transport = PollingTransport(host: self.host, path: self.path, port: self.port, secure: self.secure)
            }
            else if transportName == "websocket" {
                transport = WebsocketTransport(host: self.host, path: self.path, port: self.port, secure: self.secure)
            }
        }
        
        if transport != nil && self.id != nil{
            transport!.sid = self.id
        }
        
        return transport
    }
    
    func setTransport(inout transport: Transport){
        transport.delegate = self
        self.transport = transport
    }
    
    public func open(){
        assert(transports.count != 0)
        dispatch_async(self.queue){
            [unowned self] () -> Void in
            self.readyState = .Opening
            
            let transportName = $.first(self.transports)!
            if var transport = self.createTransport(transportName){
                self.setTransport(&transport)
                transport.open()
            }
            else{
                NSLog("Not able to create transport")
            }
        }
    }
    
    public func close(){
        // Trigger the close the underlying transport
        dispatch_async(self.queue){
            [unowned self] () -> Void in
            self.readyState = .Closing
            self.transport?.close()
        }
    }
    
    // EngineTransportDelegate
    public func transportOnPacket(transport: Transport, packet: EnginePacket) {
        if self.readyState == .Open || self.readyState == .Opening{
            NSLog("[EngineSocket] Receive: [\(packet.description)]")
            
            switch packet.type{
            case .Open:
                if let data = packet.data{
                    if let json = Converter.bytearrayToJSON(data) as? NSDictionary{
                        self.onHandshake(json)
                    }
                    else{
                        NSLog("Failed to parse json")
                        return
                    }
                }
                else{
                    NSLog("[EngineSocket] There is no data on Open packet")
                    return
                }
            case .Message:
                if let data = packet.data{
                    if let delegate = self.delegate {
                        delegate.socketOnData(self, data: data, isBinary: packet.isBinary)
                    }
                }
                else{
                    NSLog("No data on Message packet, ignore")
                }
            case .Pong:
                break
            case .Error:
                if let data = packet.data {
                    self.onError("error", reason: Converter.bytearrayToNSString(data))
                }
                else{
                    self.onError("error")
                }
            default:
                NSLog("HITTING DEFAULT CLAUSE, CAREFUL")
                break
            }
        }
        else{
            NSLog("[EngineSocket][\(self.readyState.description)] packet received with socket readyState ")
        }
    }
    
    public func transportOnError(transport: Transport, error: String, withDescription description: String) { }
    
    public func transportOnClose(transport: Transport) {
        if self.readyState == .Closing {
            NSLog("[EngineSocket][\(self.readyState.description)] The transport closed as expected")
            
            self.readyState = .Closed
            self.delegate?.socketOnClose(self)
        }
        else{
            NSLog("[EngineSocket][\(self.readyState.description)] The transport closed unexpected")
            self.delegate?.socketOnClose(self)
        }
    }
    
    public func transportOnOpen(transport: Transport) { }
    
    public func transportDispatchQueue(transport: Transport) -> dispatch_queue_t {
        // All transport related task should run on socket's queue
        return self.queue
    }
    
    // End of EngineTransport Delegate
    
    func onHandshake(data: NSDictionary){
        if let sid = data["sid"] as? String{
            self.id = sid
            self.transport!.sid = sid
        }
        else{
            NSLog("Not able to parse sid")
        }
        
        if let upgrades = data["upgrades"] as? [String]{
            self.upgrades = upgrades
        }
        
        if let pingInterval = data["pingInterval"]?.integerValue {
            self.pingInterval = pingInterval
        }
        
        if let pingTimeout = data["pingTimeout"]?.integerValue {
            self.pingTimeout = pingTimeout
        }
        
        self.onOpen()
        
        if self.readyState == .Closed{
            self.setPing()
        }
    }
    
    func onOpen(){
        NSLog("Socket Open")
        
        self.readyState = .Open
        
        if let delegate = self.delegate {
            delegate.socketOnOpen(self)
        }
        
        self.flush() // Flush out cached packets
        
        if self.readyState == .Open && self.upgrade && self.transport!.pausible {
            NSLog("Start upgrading")
            for upgrade in upgrades {
                self.probe(upgrade)
            }
        }
    }
    
    func onError(message: String, reason: String? = nil){
        
    }
    
    func setPing(){
        
    }
    
    /**
    send data
    */
    func send(data: NSData, callback: (()->Void)? = nil){
        self.send(.Message, data: Converter.nsdataToByteArray(data), isBinary: true, callback: callback)
    }
    
    /**
    Send text packet
    */
    func send(text: [Byte], callback: (()->Void)? = nil){
        self.send(.Message, data: text, isBinary: false, callback: callback)
    }
    
    // send packet and data with a callback
    func send(packetType: PacketType, data: [Byte]? = nil, isBinary: Bool, callback: (()->Void)? = nil){
        let packet = EnginePacket(data: data, type:packetType, isBinary: isBinary)
        self.packet(packet, callback: callback)
    }
    
    func flush(){
        if self.readyState != .Closed && !self.upgrading && self.transport!.writable {
            if self.writeQueue.count == 0 {
                NSLog("[EngineSocket][\(self.readyState.description)] The writeQueue is empty, return")
                return
            }
            
            NSLog("Flushing \(self.writeQueue.count) packets")
            
            // LOCK HERE
            let packets = self.writeQueue
            self.writeQueue = []
            // UNLOCK HERE
            self.transport!.write(packets)
        }
        else{
            NSLog("[EngineSocket][\(self.readyState.description)] [Upgrading:\(self.upgrading)] [Transport-writable:\(self.transport!.writable)] Skip flush")
        }
    }
    
    func probe(upgrade: String){
        
    }
    
    func packet(packet: EnginePacket, callback: (()->Void)?){
        dispatch_async(self.queue){
            [unowned self] () -> Void in
            NSLog("[EngineIOSocket][\(self.readyState.description)] Enqueue packet")
            self.writeQueue.append(packet)
            self.writeCallbackQueue.append(callback)
            self.flush()
        }
    }
}